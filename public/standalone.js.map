{"version":3,"file":"standalone.js","sources":["../index.js"],"sourcesContent":["// PubSub store\nconst topics = {};\n\n// globalize Zed\nconst w = window;\n\nexport default w.Z = {\n  // this is basically just a Promise.all polyfil\n  // A way to make multiple asynchronous ajax requests\n  // Then call a callback when all have resloved\n  load: (arr, callback) => {\n    // store for resolved requests\n    const arrResolved = [];\n    arr.forEach((obj, index) => {\n      // placehold the response as \"null\"\n      arrResolved[index] = null;\n    });\n\n    // loop over the array of objects\n    // which are the individual requests\n    arr.forEach((obj, index) => {\n\n      // check local first\n      const localStore = obj.local && obj.local();\n      if (localStore) {\n        arrResolved[index] = obj.callback\n          ? obj.callback(localStore)\n          : localStore;\n        w.Z.load[obj.id] = arrResolved[index];\n        if (!~arrResolved.indexOf(null)) {\n          callback(arrResolved);\n        }\n      } else {\n\n        // standard ajax\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n          if (xhr.readyState == 4) {\n            // update the resolved array with the response\n            arrResolved[index] =\n              xhr.status == (obj.status || 200)\n                ? // if the object has its own callback\n                  obj.callback\n                  ? // pass the response to it\n                    obj.callback(xhr.responseText)\n                  : // else just update the resolved array with the response\n                    xhr.responseText\n                : // if 404 or 405 etc resolve as undefined\n                  // NOTE: might be worth passing the\n                  // error code as the response\n                  undefined;\n\n            // make the response global using the id as the object key\n            w.Z.load[obj.id] = arrResolved[index];\n\n            // if all requests have resolved\n            if (!~arrResolved.indexOf(null)) {\n              // call the callback\n              callback(arrResolved);\n            }\n          }\n        };\n\n        // more standard ajax\n        // allow for \"PUT\" or \"POST\" methods etc\n        xhr.open(obj.method || \"GET\", obj.url, true);\n\n        // and custom headers in request\n        for (let id in obj.headers) {\n          xhr.setRequestHeader(id, obj.headers[id]);\n        }\n        xhr.send(obj.body);\n      }\n    });\n  },\n\n  // the mount method\n  mount: (obj, noSubscribe) => {\n    // only subscribe when there is an id\n    // only subscribe on Z.mount\n    if (obj.id && !noSubscribe) {\n      // create subscription\n      topics[obj.id] = {\n        // array of potential watchers\n        W: [],\n\n        // Update methods\n        F: () => {\n          // re-mount (update)\n          // not resubscribed\n          w.Z.mount(obj, true);\n        },\n      };\n    }\n\n    // assign the methods to a variables\n    const inner = obj.inner;\n    const outer = obj.outer;\n    const state = obj.state;\n    const render = obj.render(state);\n    if (inner) {\n      // render inside the mount DOM element\n      inner.innerHTML = render;\n    }\n    if (outer) {\n      // render to the mount DOM element and replace\n      outer.outerHTML = render;\n    }\n\n    // update state to global method\n    w.Z[obj.id] = state;\n  },\n\n  // the update method is just a\n  // PubSub container function\n  update: id => {\n    if (topics[id]) {\n      // Publish\n      topics[id].F();\n\n      // Publish to any watchers\n      topics[id].W.forEach(fn => {\n        fn(w.Z[id]);\n      });\n    }\n  },\n\n  // the watch method is just a\n  // PubSub container function\n  watch: (id, fn) => {\n    // Subscribe if topic (id of the mount) exists\n    topics[id] && topics[id].W.push(fn);\n  },\n};"],"names":["topics","w","window","Z","load","arr","callback","arrResolved","forEach","obj","index","localStore","local","id","indexOf","xhr","XMLHttpRequest","onreadystatechange","readyState","status","responseText","undefined","open","method","url","headers","setRequestHeader","send","body","mount","noSubscribe","W","F","inner","outer","state","render","innerHTML","outerHTML","update","fn","watch","push"],"mappings":"yBACA,IAAMA,EAAS,GAGTC,EAAIC,OAEKD,EAAEE,EAAI,CAInBC,KAAM,SAACC,EAAKC,OAEJC,EAAc,GACpBF,EAAIG,SAAQ,SAACC,EAAKC,GAEhBH,EAAYG,GAAS,QAKvBL,EAAIG,SAAQ,SAACC,EAAKC,OAGVC,EAAaF,EAAIG,OAASH,EAAIG,WAChCD,EACFJ,EAAYG,GAASD,EAAIH,SACrBG,EAAIH,SAASK,GACbA,EACJV,EAAEE,EAAEC,KAAKK,EAAII,IAAMN,EAAYG,IACzBH,EAAYO,QAAQ,OACxBR,EAASC,OAEN,KAGCQ,EAAM,IAAIC,mBAiCX,IAAIH,KAhCTE,EAAIE,mBAAqB,WACD,GAAlBF,EAAIG,aAENX,EAAYG,GACVK,EAAII,SAAWV,EAAIU,QAAU,KAEzBV,EAAIH,SAEFG,EAAIH,SAASS,EAAIK,cAEjBL,EAAIK,kBAINC,EAGNpB,EAAEE,EAAEC,KAAKK,EAAII,IAAMN,EAAYG,IAGzBH,EAAYO,QAAQ,OAExBR,EAASC,KAOfQ,EAAIO,KAAKb,EAAIc,QAAU,MAAOd,EAAIe,KAAK,GAGxBf,EAAIgB,QACjBV,EAAIW,iBAAiBb,EAAIJ,EAAIgB,QAAQZ,IAEvCE,EAAIY,KAAKlB,EAAImB,WAMnBC,MAAO,SAACpB,EAAKqB,GAGPrB,EAAII,KAAOiB,IAEb9B,EAAOS,EAAII,IAAM,CAEfkB,EAAG,GAGHC,EAAG,WAGD/B,EAAEE,EAAE0B,MAAMpB,GAAK,UAMfwB,EAAQxB,EAAIwB,MACZC,EAAQzB,EAAIyB,MACZC,EAAQ1B,EAAI0B,MACZC,EAAS3B,EAAI2B,OAAOD,GACtBF,IAEFA,EAAMI,UAAYD,GAEhBF,IAEFA,EAAMI,UAAYF,GAIpBnC,EAAEE,EAAEM,EAAII,IAAMsB,GAKhBI,OAAQ,SAAA1B,GACFb,EAAOa,KAETb,EAAOa,GAAImB,IAGXhC,EAAOa,GAAIkB,EAAEvB,SAAQ,SAAAgC,GACnBA,EAAGvC,EAAEE,EAAEU,SAOb4B,MAAO,SAAC5B,EAAI2B,GAEVxC,EAAOa,IAAOb,EAAOa,GAAIkB,EAAEW,KAAKF"}